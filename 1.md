Okay, I've read through the existing Docusaurus content. It's a solid start, very clear and concise, which is great for initial onboarding. However, to truly leverage the maximum token count (60,000) and provide a comprehensive, industry-leading documentation suite, we need to significantly expand the depth, detail, and examples across all sections.

This isn't just about adding words; it's about enriching the content with more technical explanations, visual cues (which the writer will implement), extended user scenarios, edge cases, and a more persuasive, expert tone.

I will provide the expanded content for each `.md` file, ensuring a balance between user-friendliness and technical precision. I'll maintain the existing structure and `sidebar_position` for continuity.

---

**Strategy for Expansion:**

1.  **Deeper Explanations:** Elaborate on concepts like CPMM, Nostr, and TLS Notary with more accessible analogies and technical nuances.
2.  **Extended User Flows:** Add more granular steps, edge cases, and potential troubleshooting tips.
3.  **Visual Prompts:** Suggest where diagrams, screenshots, or GIFs would significantly enhance understanding.
4.  **Real-World Scenarios:** Inject more concrete examples, especially involving the interaction between different platform features.
5.  **FAQs/Troubleshooting:** Anticipate common user questions and provide clear answers.
6.  **"Why" and "How":** For every feature, explain not just *what* it is, but *why* it's designed that way and *how* it fundamentally works.
7.  **SEO & Keywords:** Naturally embed relevant keywords to improve searchability (e.g., Bitcoin L2, Taproot Assets, Lightning Network, Nostr protocol, social finance, web3, creator economy).
8.  **Professional Tone:** Maintain a confident, expert tone that inspires trust, while still being accessible.

---

**Expanded Docusaurus Content (Aiming for significant expansion in each file):**

---

File: `/docs/advanced/cpmm-price-impact.md`

```markdown
---
sidebar_position: 1
---

# The CPMM and Price Impact: Unpacking postfun's Dynamic Pricing

## Understanding the Pricing Mechanism: How postfun Determines Value

At the heart of every `postfun` Content Pool lies a sophisticated yet elegantly simple mathematical model: the **Constant Product Market Maker (CPMM)**. This isn't just a fancy term; it's the engine that dynamically sets the price of your tokens based purely on supply and demand within that specific pool. Unlike traditional order books where buyers and sellers list their exact prices, the CPMM uses an algorithmic approach to ensure there's always a market for your tokens, regardless of whether you're buying or selling.

This deterministic pricing model is crucial for `postfun` because it allows us to create instant, liquid markets for any tweet, bypassing the need for initial price discovery or manual liquidity provision.

## The Foundational Formula: `x * y = k`

The CPMM operates based on a single, unchanging equation:

`virtual_reserve * token_reserve = constant (k)`

Let's break down each component:

*   **`virtual_reserve (x)`**: This is a conceptual representation of the amount of Bitcoin (sats) within the bonding curve. It's a **pricing parameter**, not a physical stash of sats. Its value shifts dynamically to maintain the constant `k` as tokens are bought, sold, or burned. Crucially, this `virtual_reserve` starts at a predefined value (e.g., 10,000,000 sats at Level 1) and *increases* over time as tokens are burned.

*   **`token_reserve (y)`**: This represents the actual, real quantity of tokens within the bonding curve's reserve. When you buy tokens, they are removed from this reserve. When you sell tokens, they are returned to this reserve. This `token_reserve` decreases as tokens are distributed to holders and further decreases dramatically during our automated token burn events.

*   **`constant (k)`**: This is the unchanging factor. It is calculated once at the very moment a Content Pool is minted (e.g., `10,000,000 virtual_sats * 1,000,000,000 tokens = 19 * 10^15`). This `k` value remains fixed throughout the entire lifecycle of the pool, ensuring the fundamental mathematical relationship between the virtual sats and token reserves is always preserved.

**How Price is Derived:** The current price of a single token is effectively `virtual_reserve / token_reserve`. As the `token_reserve` decreases (due to buys or burns), the price per token naturally increases.

## Understanding Price Impact: Your Trades Shape the Market

Every time a buy or sell transaction occurs within a `postfun` Content Pool, it directly affects the `virtual_reserve` and `token_reserve` values, which in turn moves the price along the curve. This is known as **Price Impact**.

*   **When you BUY tokens:**
    *   The `sats` you spend (after fees) are added to the **real** `bitcoin_reserve` (more on this below).
    *   The corresponding number of `tokens` are removed from the `token_reserve` and transferred to your wallet.
    *   Because `token_reserve (y)` decreases, to maintain the `constant (k)`, the `virtual_reserve (x)` must increase. This results in the price of the token increasing. Larger buys cause a larger increase.

*   **When you SELL tokens:**
    *   The `tokens` you sell are returned to the `token_reserve`.
    *   The corresponding `sats` are removed from the **real** `bitcoin_reserve` and sent to your wallet.
    *   Because `token_reserve (y)` increases, to maintain the `constant (k)`, the `virtual_reserve (x)` must decrease. This results in the price of the token decreasing. Larger sells cause a larger decrease.

The `postfun` user interface (on both the website and the extension) will always clearly display the estimated price impact of your trade *before* you confirm it. This transparency ensures you understand how your transaction will affect the market.

## Why Token Burns Are Powerful: Accelerating Scarcity for Price Appreciation

This is where `postfun` truly innovates beyond a standard CPMM. Our automated token burn events are a built-in mechanism designed to create **accelerating scarcity** and consequently **permanent, upward pressure on the token's price**.

Here's the genius:

1.  **Fixed Constant `k`:** Remember, `virtual_reserve * token_reserve = k`, and `k` *never changes*.
2.  **Token Burns Reduce `y`:** During a burn event (e.g., 50 million tokens at Level 2), a significant chunk of the `token_reserve (y)` is permanently destroyed.
3.  **`x` Must Increase:** Since `k` is fixed, if `y` decreases, then `x` (the `virtual_reserve`) *must* increase proportionally to maintain `k`.
4.  **Price Rises:** Because `x` represents the virtual value that determines price, an increase in `x` directly translates to an increase in the price of the remaining tokens.

**The Impact:** Every token burn directly and irrevocably shifts the entire bonding curve upwards. This means that after a burn, the lowest possible price a token can be traded at is significantly higher than it was before the burn. This mechanism fundamentally rewards long-term holders and incentivizes the community to push pools to higher levels, creating a self-reinforcing cycle of price appreciation and engagement.

**Illustrative Example (Conceptual):**

*   **Before Burn:** `10,000,000 (virtual sats) * 1,000,000,000 (tokens) = 19 * 10^15 (k)`
*   **After 50M Token Burn:** `token_reserve` becomes `950,000,000`.
    *   `x_new = k / y_new = (19 * 10^15) / 950,000,000 = 20,000,000`
    *   The `virtual_reserve (x)` has increased from 10M to 20M, effectively doubling the underlying pricing base, even though no new sats have entered the real reserve due to a buy.

This mechanism ensures that participating in `postfun` is not just about short-term speculation but about actively contributing to the long-term, fundamental value growth of the digital assets you hold.
```

---

File: `/docs/creators/claiming-earnings.md`

```markdown
---
sidebar_position: 2
---

# How to Claim Your Earnings: Unlocking Your Content's Value

## Securely Linking Your Account: Proving Ownership Without Compromise

As a content creator, you automatically earn a share of every trade on any `postfun` Content Pool created from your tweets. To claim these earnings and receive your special Graduation Bonus, you first need to securely link your X (Twitter) account to your `postfun` Nostr identity.

We understand that security and privacy are paramount for creators. That's why `postfun` uses a cutting-edge, privacy-preserving technology called **TLS Notary**. This allows you to cryptographically prove to our backend that you are the legitimate owner of your X account, **without ever sharing your password, cookies, or any sensitive login credentials with us.**

### Why TLS Notary is Essential:
*   **Privacy First:** Your X login details remain entirely private and are never transmitted to `postfun` servers.
*   **Non-Custodial Proof:** You generate a cryptographic "receipt" directly from your browser, which our system can verify.
*   **Trust-Minimized:** It removes the need for `postfun` to act as a trusted third party in the identity verification process.

## The Secure Claiming Process: Step-by-Step Guide

Follow these steps carefully to link your account and claim the value your content has generated:

1.  **Navigate to Your User Page:**
    *   Open your web browser and go to `https://postfun.xyz/user/<your_twitter_username>`. Replace `<your_twitter_username>` with your actual X.com handle (e.g., `postfun.xyz/user/elonmusk`).
    *   *(Suggested Visual: Screenshot of a profile page, highlighting the "Claim Earnings" button)*

2.  **Initiate Claim Earnings:**
    *   Once on your profile page, ensure you are logged into `postfun` with your Nostr identity (via the `postfun` extension).
    *   Click the prominent "**Claim Earnings**" button.
    *   A modal will appear, explaining the next steps and the TLS Notary process.

3.  **Generate Proof of Ownership (Using the `postfun` Extension):**
    *   The `postfun` extension is crucial for this step. When prompted by the website, the extension will guide you through generating the TLS Notary proof.
    *   This typically involves opening a new, temporary browser window or tab where you will briefly interact with X.com. The extension will observe this session to cryptographically attest that you are indeed logged into that specific X account.
    *   **Important:** Follow the on-screen instructions precisely. Do not close the temporary window until the proof generation is complete.
    *   *(Suggested Visual: Animated GIF showing the TLS Notary process, including the temporary browser window and confirmation)*

4.  **Proof Submission & Verification:**
    *   Once the proof is successfully generated by the extension, it will be automatically submitted to the `postfun` backend.
    *   Our backend will cryptographically validate the proof. This typically takes only a few seconds.

5.  **Secure Account Linking:**
    *   Upon successful verification, your X account is now securely and permanently linked to your `postfun` Nostr wallet. This link is stored in our database, associating your `npub` with your X username.
    *   The "Claim Earnings" button on your profile page will now be active, and your "Earned" balance will be visible.

6.  **Claim Your Sats:**
    *   Click the "**Claim**" button.
    *   All the `sats` accumulated from your content's trading fees and any Graduation Bonuses will be instantly transferred from your designated creator balance to your main `postfun` Lightning wallet balance. These funds are immediately available for trading, deposits, or withdrawals.

This robust and privacy-preserving process ensures that only you, the rightful content creator, can claim the earnings from your viral content, cementing `postfun` as the definitive platform for monetizing social influence.
```

---

File: `/docs/creators/earning-on-postfun.md`

```markdown
---
sidebar_position: 1
---

# How You Earn on postfun (Automatically!): A Creator's Guide to Monetization

## Focus on Your Content, We Handle the Monetization

As a content creator on X (formerly Twitter), your primary focus is to craft compelling, insightful, or entertaining tweets that resonate with your audience. You build influence, spark conversations, and shape narratives. Traditionally, monetizing this inherent social value has been a fragmented, often cumbersome process involving ad revenue, sponsorships, or direct fan support.

`postfun` revolutionizes this. We provide an automatic, passive, and direct monetization stream for your content, allowing you to earn from the very act of cultural engagement. **You create, your audience engages, and `postfun` ensures you're rewarded for the value you generate.**

## Continuous Earnings: Your Share of Every Swap

Every single Content Pool created from one of your tweets on `postfun` is an active market. Every time a user (a "Trader") buys or sells tokens within that pool, a small transaction fee is applied.

Here's the exciting part: **you, as the original content creator, automatically earn 15% of that fee on every single swap, forever!**

*   **Passive Income:** This earning stream is entirely passive. Once a pool for your tweet exists, you don't need to do anything further to earn.
*   **Real-time Accumulation:** Your share of fees accumulates in a dedicated balance on our backend, waiting for you to claim it.
*   **Volume-Driven:** The more popular your tweet's pool becomes, and the more trading volume it generates, the more `sats` you accumulate.

*(Suggested Visual: A simple diagram showing "Tweet -> postfun Pool -> Buy/Sell Swap -> Fee Collected -> 15% to Creator")*

## The Graduation Bonus: A Massive Payout for Breakthrough Content

While continuous swap fees provide a steady stream, the true game-changer for creators is the **Graduation Bonus**. This is a significant lump-sum payout designed to reward creators whose content achieves viral success and generates substantial economic activity on `postfun`.

*   **What is Graduation?** A Content Pool "graduates" when its real `bitcoin_reserve` reaches **100,000,000 sats (1 BTC)**. This signifies that your tweet has fostered a robust, highly active market.
*   **Your Reward:** If your post's pool achieves this monumental milestone, you receive a massive bonus of **5% of the entire 1 BTC pot**, equating to **5,000,000 sats!** This is a direct, substantial reward for cultivating a truly impactful piece of content.

*(Suggested Visual: An infographic showing the pool's progression through levels, culminating in the 1 BTC target and highlighting the 5% creator share in the payout distribution.)*

## Real-World Example: Elon Musk's Impact, Directly Monetized

Let's use the hypothetical example of a highly influential figure like Elon Musk and his impact on crypto culture.

*   **The Tweet:** Imagine Elon posts a thought-provoking tweet about the future of energy, sparking widespread debate and engagement.
*   **The Minter's Vision:** A `postfun` user (a "Minter") recognizes the tweet's potential cultural and economic impact and decides to create a Content Pool for it on `postfun`. They pay the 1,000 sat minting fee.
*   **The Trading Frenzy:** Driven by excitement, analysis, and speculation, thousands of `postfun` users begin buying and selling tokens in "The Elon Energy Token" pool. Each swap generates a fee.
*   **Elon's Passive Income:** For every single buy and sell transaction, 15% of that fee (e.g., 150 `sats` from a 1,000 `sat` fee) is automatically earmarked for a wallet controlled by `postfun`, waiting for Elon to claim.
*   **The Graduation:** If "The Elon Energy Token" pool hits the 1 BTC `bitcoin_reserve` milestone, it graduates. Beyond the ongoing fees, Elon automatically becomes eligible for a **5,000,000 sat bonus** from that 1 BTC pool!

This example clearly illustrates how `postfun` transforms ephemeral social engagement into a tangible, ongoing, and potentially life-changing income stream for creators. Your content's cultural impact now has a direct, measurable financial value.

**Ready to start earning?** Link your X.com account to `postfun` and claim your accumulated sats! Find out how in "How to Claim Your Earnings."
```

---

File: `/docs/developer/brand-kit.md`

```markdown
---
sidebar_position: 4
---

# The `postfun` Brand Kit: Guidelines for Our Visual Identity

## Our Commitment to Brand Consistency

The `postfun` brand is more than just a logo; it's a representation of our values: innovation, dynamism, community, and fun. This Brand Kit provides comprehensive guidelines for how to properly use our visual assets. Adhering to these guidelines ensures a consistent and recognizable presence across all platforms and applications built on or around the `postfun` ecosystem.

Whether you're building a third-party application, creating promotional materials, or simply writing about `postfun`, these rules help maintain the integrity and impact of our brand.

## Logo: The Heart of `postfun`

The `postfun` logo is our primary visual identifier. It should always be used with care and respect for its design.

### Available Formats:
*   **SVG (Scalable Vector Graphics):** Ideal for digital use at any size without loss of quality.
*   **PNG (Portable Network Graphics):** Provided in high-resolution raster formats for various applications, including transparent backgrounds.
    *   **Variations:** Logos are available for both light and dark backgrounds to ensure optimal visibility and contrast.

### Download Logos:
*(Suggested Visual: A "Download Logos" button or section linking to a ZIP archive with all logo files. Display examples of the logo on light and dark backgrounds.)*

## Color Palette: The Vibrancy of `postfun`

Our brand uses a vibrant, energetic color scheme that reflects the dynamic nature of our platform. These colors should be used consistently across all materials.

| Color Name        | Hex Code      | Description                                     |
| :---------------- | :------------ | :---------------------------------------------- |
| **Primary Pink**  | `#FF69B4`     | Our signature hue, representing innovation.     |
| **Magenta**       | `#FF00FF`     | A bright, bold secondary color for emphasis.    |
| **Accent Cyan**   | `#00BFFF`     | A vibrant contrast color for calls-to-action.   |
| **Dark Background** | `#121212`   | Our primary background color, deep and modern. |
| **Light Background** | `#FFFFFF`  | Used sparingly for contrast and accessible text. |
| **Text Primary**  | `#E0E0E0`     | Ideal for main text on dark backgrounds.        |
| **Text Secondary**| `#A0A0A0`     | For supporting text and subtle UI elements.     |

*(Suggested Visual: A color swatch display showing each color with its HEX code.)*

## Typography: Our Voice in Print

The official font used across `postfun` digital properties is **Inter**.

*   **Font Family:** `Inter` (Sans-serif)
*   **Usage:** It provides a clean, modern, and highly legible experience, suitable for both headlines and body text.
*   **Where to find it:** Inter is available via Google Fonts.

*(Suggested Visual: Examples of headlines and body text using the Inter font.)*

## Usage Guidelines: Protecting the `postfun` Brand

To ensure the strength and recognition of the `postfun` brand, please adhere to these guidelines.

### **Do:**
*   **Use our logo to link to `https://postfun.xyz`** or to specific pages within the platform.
*   **Maintain adequate clear space** around the logo. This "breathing room" ensures its visibility and impact. (e.g., "The clear space around the logo should be at least X% of the logo's width.")
*   **Use the correct color variations** for light/dark backgrounds to ensure optimal contrast and readability.
*   **Scale the logo proportionally** to avoid distortion.
*   **Use the official color palette** for any UI elements or graphics associated with `postfun`.

### **Don't:**
*   **Alter the colors or proportions of the logo** (unless using the approved light/dark variations).
*   **Rotate, distort, or stretch the logo** in any way.
*   **Place the logo on busy backgrounds** where it loses clarity.
*   **Use the logo as a background element** or overlay it with text.
*   **Create derivative or unofficial versions of the logo** or brand marks.
*   **Use `postfun` in a way that implies endorsement or partnership** without official authorization.

By following these guidelines, you help us maintain a strong, consistent, and trusted brand identity for the `postfun` ecosystem.
```

---

File: `/docs/developer/building-on-postfun.md`

```markdown
---
sidebar_position: 1
---

# Building on `postfun`: Extending the Protocol for Cultural Value

## The Vision: Your Innovation, Our Foundation

At `postfun`, we believe that the true power of web3 lies in open, composable protocols. While our official platform (`postfun.xyz` and its browser extension) provides a robust and engaging user experience, it's just the beginning. We envision a future where developers like you build an entire ecosystem of tools, services, and applications that leverage `postfun`'s underlying protocol for cultural value.

The publicly accessible API is the cornerstone of this vision, designed to open up the `postfun` experience for everyone. We warmly invite you to explore our endpoints, understand our mechanics, and build with us. Your creativity will unlock new possibilities for how content creators and communities monetize their influence.

## What You Can Build: Unleashing Your Creativity

The possibilities are vast when you build on top of `postfun`. Here are just a few ideas to spark your imagination:

### 1. Trading Bots
*   **Concept:** Automate buying and selling strategies for `postfun` tokens.
*   **Capabilities:** Program bots to execute trades based on real-time social signals (e.g., tweet virality, sentiment analysis), specific `postfun` metrics (e.g., volume spikes, liquidity changes), or pool progression towards graduation milestones.
*   **Impact:** Contribute to market efficiency and liquidity, or leverage your analytical edge.

### 2. Advanced Analytics Dashboards
*   **Concept:** Create custom data visualizations and insights beyond what the official `postfun` website provides.
*   **Capabilities:** Track minter profitability over time, analyze creator earnings trends, identify patterns in graduated pools, or visualize the most active traders.
*   **Tools:** Utilize tools like Dune Analytics (if our data is publicly accessible/indexed), or build custom dashboards by hitting our public API endpoints and storing data locally.

### 3. Telegram/Discord Bots
*   **Concept:** Bring real-time `postfun` market updates directly to your community's favorite chat platforms.
*   **Capabilities:** Develop bots that pipe notifications for:
    *   **New Mints:** Announce a new Content Pool creation instantly.
    *   **Level-Ups:** Broadcast when a pool hits a new level (Spark, Bonfire, Inferno) and experiences a token burn.
    *   **Large Swaps:** Highlight significant buy or sell orders.
    *   **Graduations:** Celebrate when a pool makes it to the final stage and gets listed on a DEX.
*   **Impact:** Keep your community engaged and informed without them constantly checking the website. (See our dedicated tutorial: "Tutorial: Building a 'New Mints' Telegram Bot").

### 4. Custom UIs & Trading Interfaces
*   **Concept:** Build alternative frontends or specialized trading interfaces tailored to specific user groups or trading styles.
*   **Capabilities:** Create mobile-optimized interfaces, desktop applications, or niche trading terminals with unique features not available on the main site.
*   **Impact:** Provide diverse access points and cater to specialized needs within the `postfun` ecosystem.

### 5. Social Integrations
*   **Concept:** Connect `postfun` data with other social platforms beyond X.com (e.g., Farcaster, Lens Protocol).
*   **Capabilities:** Develop bridges that allow `postfun` event data to flow into other social graphs, or integrate `postfun` trading into alternative social UIs.

## Getting Access & Fair Use Policy

The `postfun` public `GET` API endpoints are open and available for immediate use without authentication. We encourage you to start exploring and experimenting with these endpoints to understand the data available.

*   **API Reference:** For a detailed breakdown of all available endpoints, including request/response formats, please refer to our [API Reference](/docs/mechanics/api-reference).

### Rate Limits
Current rate limits apply to all requests to ensure fair usage and platform stability. For general public endpoints, these limits are generous enough for most exploratory and small-scale application development.

### Accessing Authenticated Endpoints
For high-volume use cases or to request an API key for accessing authenticated `POST` endpoints (like `POST /swaps` or `POST /mints` programmatically), please reach out to our team. This process ensures we can understand your use case and provide the necessary support and access, while maintaining the security and integrity of the platform.

**Contact Us:** Please connect with our team through our official [Discord server](/docs/developer/community-support#join-our-discord) or send an email to `partnerships@postfun.xyz` to discuss your specific needs and access requirements for authenticated endpoints.

We look forward to seeing the innovative ways you'll expand the `postfun` universe!
```

---

File: `/docs/developer/community-support.md`

```markdown
---
sidebar_position: 5
---

# Community & Support: Connect, Collaborate, and Innovate with `postfun`

## Our Commitment to a Thriving Ecosystem

At `postfun`, we believe that a strong community is the bedrock of any successful decentralized platform. We are committed to fostering an environment where users, creators, and developers can connect, share ideas, get support, and collaboratively build the future of social finance. Your engagement is what drives `postfun` forward.

## Join our Discord: Your Real-time Hub

Our official Discord server is the most vibrant and active center for the `postfun` community. It's the ultimate place to:

*   **Get Real-time Support:** Our team and experienced community members are often available to answer your questions about trading, wallet setup, or platform features.
*   **Developer Chat:** Connect directly with our core development team and other builders. Discuss API integrations, propose new features, or troubleshoot your projects.
*   **Alpha & Announcements:** Be the first to hear about new features, major updates, partnership announcements, and exciting community events.
*   **Trading Insights:** Share strategies, analyze trending pools, and discuss market movements with fellow traders.
*   **Creator Network:** Connect with other content creators, share best practices for monetizing your tweets, and discover new ways to leverage `postfun`.

We encourage all users, regardless of their technical background, to join and become an active part of our growing community.

[**ðŸš€ Join our Discord Server**](https://discord.gg/postfun) *(This link should be replaced with the actual Discord invite link)*

## Follow us on X.com: Stay Updated

X.com (formerly Twitter) is where the cultural conversation happens, and it's where `postfun` lives. Follow our official account to stay abreast of the latest news, product updates, and engaging content.

*   **Official Announcements:** We'll tweet about new features, major platform milestones, and important security advisories.
*   **Trending Pools:** We'll highlight exciting Content Pools, successful graduations, and noteworthy market movements.
*   **Community Highlights:** We'll retweet innovative projects built on `postfun` and celebrate community achievements.

[**ðŸ¦ Follow @postfun on X.com**](https://x.com/postfun) *(This link should be replaced with the actual X.com profile link)*

## GitHub (Future): Transparent and Open-Source Development

We are committed to the principles of transparency and open-source development. While the `postfun` platform is currently a closed-source project, we have a strong intention to progressively open-source key parts of our stack in the future.

*   **What to Expect:** This could include our core CPMM logic, worker implementations, API client libraries, or even components of our frontend.
*   **Why Open Source?** We believe open-sourcing will foster greater community trust, enable independent security audits, and empower developers to build even more deeply integrated and innovative tools on `postfun`.

**Stay Tuned:** We will make formal announcements regarding our GitHub repository and open-source initiatives through our Discord and X.com channels.

## Bug Bounty Program: Our Commitment to Security

Security is non-negotiable at `postfun`. We employ rigorous internal testing, code reviews, and industry best practices to protect our platform and your funds. However, we recognize that no system is infallible, and the broader security community is an invaluable asset.

We are establishing a **Bug Bounty Program** to incentivize and reward security researchers who responsibly discover and report vulnerabilities in our platform.

### How to Report a Vulnerability:
*   **Responsible Disclosure:** If you believe you have found a security flaw, please do NOT disclose it publicly.
*   **Contact Us:** Immediately report the vulnerability by sending a detailed email to: `security@postfun.xyz`
*   **Required Information:**
    *   A clear and concise description of the vulnerability.
    *   Detailed steps to reproduce the vulnerability.
    *   Screenshots, video recordings, or code snippets that demonstrate the issue (if applicable).
    *   Your assessment of the potential impact of the vulnerability.
    *   Any proposed mitigations or fixes (optional, but helpful).

We commit to a timely response, transparent communication, and fair rewards for valid, responsibly disclosed vulnerabilities. Your efforts help make `postfun` safer for everyone.
```

---

File: `/docs/developer/nostr-integration.md`

```markdown
---
sidebar_position: 3
---

# Understanding Nostr Integration (NIP-07): Secure Authentication for Your `postfun` Apps

## The "Signer" Principle: Your Private Key, Always in Your Control

At `postfun`, security and user self-custody are paramount. Unlike traditional web applications that rely on username/password combinations or email-based logins, `postfun` uses the **Nostr protocol** for its core identity and authentication. Specifically, we leverage **NIP-07**, a standard that allows web applications to interact with a Nostr key manager (like our `postfun` Chrome Extension) without ever directly accessing the user's private key (`nsec`).

Think of it this way:

*   **Your `postfun` Extension:** This acts as your secure **"Signer."** It's like a hardware wallet or a physical key that holds your `nsec` securely inside your browser. It has the *ability* to sign Nostr events.
*   **`postfun.xyz` Website (or your DApp):** This acts as the **"Requester."** It needs certain Nostr events to be signed (like a login event or a trade execution event).
*   **The Interaction:** The Requester asks the Signer (your extension) to sign an event. The Signer *then prompts you for permission*. If you approve, the Signer uses your `nsec` to sign the event *locally within the extension* and returns the signed event to the Requester. **Your `nsec` never leaves the extension.**

This model is critical for ensuring that you retain full control and custody of your Nostr identity and, by extension, your `postfun` account.

## The Login Flow: Step-by-Step for Frontend Developers

To integrate `postfun`'s secure authentication into your own web applications (DApps), you'll follow this standard NIP-07 flow. This process typically occurs when a user clicks a "Login" or "Connect Wallet" button on your frontend.

### 1. Check for the `window.nostr` Provider

The `postfun` Chrome Extension (and other NIP-07 compatible extensions) injects a `window.nostr` object into the browser's JavaScript environment. Your application should first check for its presence.

```javascript
// Check if a NIP-07 compatible extension is installed and active
if (typeof window.nostr !== 'undefined') {
  console.log("Nostr extension detected!");
  // Proceed with login logic
} else {
  console.error("Nostr extension not found. Please install postfun extension to log in.");
  // Prompt user to install the extension
}
```

### 2. Generate a Unique Login Challenge

To prevent replay attacks (where an attacker uses an old signed login event), your backend *must* issue a unique, unpredictable "challenge" string for each login attempt. The frontend will include this challenge in the Nostr event it asks the user to sign.

```javascript
// Example: Fetch a challenge from your backend
// Your backend would generate this challenge and store it temporarily
const response = await fetch('https://postfun.xyz/api/auth/challenge');
const { challenge } = await response.json();

console.log("Received challenge:", challenge);
```

### 3. Craft the Nostr Event Template

You'll create a standard Nostr event object (but *without* a signature yet). For login, the `Kind 22242` ("Ephemeral Event") is commonly used as it's not meant to be stored by relays long-term. The `content` field will contain the unique challenge.

```javascript
const eventTemplate = {
  kind: 22242, // Ephemeral event kind
  created_at: Math.floor(Date.now() / 1000), // Current Unix timestamp
  tags: [], // Optional tags, can be empty for login
  content: JSON.stringify({ challenge: challenge, purpose: "postfun login" }) // Include your challenge here
};

console.log("Event template to sign:", eventTemplate);
```

### 4. Request Signature from the Extension

Now, call `window.nostr.signEvent()` on the event template. This is the crucial step that triggers the extension's user prompt.

```javascript
try {
  const signedEvent = await window.nostr.signEvent(eventTemplate);
  console.log("Signed event received from extension:", signedEvent);
  // Now send this signedEvent to your backend for verification
} catch (error) {
  console.error("User denied signing or an error occurred:", error);
  // Handle user cancellation or extension error
}
```

### 5. Send the Signed Event to Your Backend

Your backend will verify this `signedEvent` to authenticate the user. Refer to the [Backend API Reference](/docs/mechanics/api-reference) for the exact endpoint.

```javascript
const loginResponse = await fetch('https://postfun.xyz/api/auth/login', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify(signedEvent)
});

if (loginResponse.ok) {
  const { token } = await loginResponse.json();
  console.log("Login successful! Received JWT:", token);
  // Store this JWT (e.g., in localStorage or an authentication context)
  // for all subsequent authenticated API requests.
} else {
  console.error("Backend login failed:", await loginResponse.text());
  // Handle backend authentication errors
}
```

### 6. Using the JWT for Authenticated Requests

Once you have the JWT, attach it to the `Authorization` header of all subsequent authenticated API calls to the `postfun` backend.

```javascript
// Example: Fetch user's private dashboard data
const jwt = localStorage.getItem('postfun_jwt'); // Assuming you stored it
const myDataResponse = await fetch('https://postfun.xyz/api/me', {
  headers: {
    'Authorization': `Bearer ${jwt}`
  }
});

if (myDataResponse.ok) {
  const userData = await myDataResponse.json();
  console.log("User data:", userData);
} else {
  console.error("Failed to fetch user data.");
}
```

## Security Best Practices for Developers

When building with NIP-07 and `postfun` authentication, always keep these critical security principles in mind:

*   **Never Request the User's `nsec` Directly:** The entire purpose of NIP-07 is to abstract this away. If your application asks for an `nsec`, it's a red flag.
*   **Always Use Unique Challenges:** Each login attempt (or any signed action) should use a unique, single-use challenge generated by your backend. This prevents replay attacks.
*   **Verify Signatures on the Backend:** Never trust a signed event received directly from the frontend. Always send the full signed event to your backend for cryptographic verification before granting access or performing any action.
*   **Handle User Cancellations:** Users can always decline a signing request from the extension. Your code must gracefully handle this scenario.
*   **JWT Security:** Store JWTs securely (e.g., in `localStorage` for convenience, but be aware of XSS risks; `HttpOnly` cookies from a backend are more secure for server-rendered apps). Ensure your JWTs have short expiry times.
*   **Rate Limiting:** Implement rate limiting on your API endpoints to prevent abuse.

By following these guidelines, you can build secure and robust applications that integrate seamlessly with the `postfun` ecosystem, empowering users with true self-custody and decentralized identity.
```

---

File: `/docs/developer/telegram-bot-tutorial.md`

```markdown
---
sidebar_position: 2
---

# Tutorial: Building a "New Mints" Telegram Bot for `postfun`

## Introduction: Bridging `postfun` and Your Community

`postfun` is a dynamic marketplace, with new Content Pools being minted constantly. As a developer or community manager, you might want to keep your audience updated in real-time. This tutorial will guide you through building a simple Python-based Telegram bot that monitors for new `postfun` mints and automatically posts them to your Telegram channel or group.

This is a great starting point for understanding how to interact with the `postfun` API and can be easily extended to track other events like Level-Ups, major trades, or graduations.

## Prerequisites

Before you begin, make sure you have the following:

*   **Python 3.8+:** Installed on your system.
*   **`requests` library:** For making HTTP requests to the `postfun` API.
*   **`python-telegram-bot` library:** A powerful and easy-to-use library for building Telegram bots. (We'll use `requests` for simplicity in this example, but for a full bot, this is recommended).
*   **A Telegram Bot Token:** You'll need to create a new bot via Telegram's BotFather (`@BotFather`).
*   **A Telegram Chat ID:** The ID of the group or channel where your bot will send messages. (You can get this by adding your bot to a group and sending `/my_id@YourBotName` in the group, or using a service like `@get_id_bot`).

## Step 1: Scaffolding the Bot and Configuration

Create a new Python file (e.g., `postfun_bot.py`) and set up your basic configurations.

```python
import requests
import time
import json
import os # For environment variables

# --- Bot Configuration ---
# Base URL for the postfun API
API_BASE_URL = "https://api.postfun.xyz" # Using the official API endpoint for the backend

# Telegram Bot Token (GET THIS FROM BOTFATHER)
# It's best practice to use environment variables for sensitive info
TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN", "YOUR_TELEGRAM_BOT_TOKEN_HERE")
# Telegram Chat ID (Your group/channel ID)
TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID", "YOUR_TELEGRAM_CHAT_ID_HERE")

# --- State Management ---
# File to store the ID of the last tweet we've seen to avoid re-sending old notifications
LAST_SEEN_FILE = "last_seen_tweet_id.txt"

# --- Polling Interval ---
# How often the bot will check for new mints (in seconds)
POLLING_INTERVAL_SECONDS = 300 # 5 minutes
```

## Step 2: Fetching the Latest Mints from `postfun` API

We'll define a function to call the `postfun` backend's `/tweets` endpoint. We'll sort by `"new"` to get the most recently minted pools.

```python
def get_latest_mints():
    """
    Fetches the latest minted tweets from the postfun API.
    """
    params = {
        "by": "new",  # Sort by newly minted
        "limit": 10   # Get a few recent ones to check for new additions
    }
    try:
        response = requests.get(f"{API_BASE_URL}/tweets", params=params, timeout=10)
        response.raise_for_status() # Raise an exception for bad status codes (4xx or 5xx)
        return response.json()
    except requests.exceptions.RequestException as e:
        print(f"Error fetching latest mints: {e}")
        return [] # Return empty list on error
```

## Step 3: Managing Bot State - `last_seen_tweet_id`

To ensure your bot only sends notifications for *new* mints and doesn't spam your channel with old ones every time it runs, we need a way to store the ID of the last tweet it successfully processed.

```python
def get_last_seen_id():
    """
    Reads the last seen tweet ID from a local file.
    Returns None if the file doesn't exist or is empty.
    """
    try:
        with open(LAST_SEEN_FILE, 'r') as f:
            content = f.read().strip()
            return int(content) if content.isdigit() else None
    except FileNotFoundError:
        return None
    except Exception as e:
        print(f"Error reading last seen ID file: {e}")
        return None

def save_last_seen_id(tweet_id):
    """
    Saves the given tweet ID to a local file.
    """
    try:
        with open(LAST_SEEN_FILE, 'w') as f:
            f.write(str(tweet_id))
    except Exception as e:
        print(f"Error saving last seen ID file: {e}")
```

## Step 4: Formatting the Telegram Message

We need to format the data received from the `postfun` API into a user-friendly message for Telegram. Telegram supports Markdown for rich text formatting.

```python
def format_message(tweet_data):
    """
    Formats a single tweet's data into a Telegram Markdown message.
    """
    tweet_id = tweet_data.get('id', 'N/A')
    tweet_username = tweet_data.get('tweetUsername', 'N/A')
    # Truncate content for brevity
    tweet_content = tweet_data.get('description', 'No content available.')[:150] + "..." if len(tweet_data.get('description', '')) > 150 else tweet_data.get('description', 'No content available.')
    minter_npub = tweet_data.get('minterId', 'N/A')[:12] + "..." if len(tweet_data.get('minterId', '')) > 12 else tweet_data.get('minterId', 'N/A')

    # Basic stats for the mint
    current_price_sats = tweet_data.get('priceSatsPerToken', 'N/A') # Assuming API returns this
    volume_24h_sats = tweet_data.get('volume24H', 'N/A')
    liquidity_sats = tweet_data.get('liquidity', 'N/A')
    current_level = tweet_data.get('level', 'N/A')

    return f"""
ðŸš¨ *NEW MINT ALERT!* ðŸš¨

*Content:* `{tweet_content}`
*From:* @{tweet_username}

*Minter:* `{minter_npub}`
*Current Level:* {current_level}

*Current Price:* {current_price_sats} sats/token
*24h Volume:* {volume_24h_sats} sats
*Liquidity:* {liquidity_sats} sats

[âž¡ï¸ View on postfun.xyz](https://postfun.xyz/tweet/{tweet_id})

#postfun #newmint
"""
```

**Note:** The `tweet_data` dictionary structure in `format_message` assumes the `/tweets` API returns `id`, `tweetUsername`, `description`, `minterId`, `priceSatsPerToken`, `volume24H`, `liquidity`, and `level`. Adjust based on your actual API response.

## Step 5: Sending the Message to Telegram

This function handles the actual communication with the Telegram Bot API.

```python
def send_telegram_message(message):
    """
    Sends a formatted Markdown message to the specified Telegram chat.
    """
    if not TELEGRAM_BOT_TOKEN or not TELEGRAM_CHAT_ID:
        print("Telegram bot token or chat ID not configured. Skipping message.")
        return

    url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
    payload = {
        "chat_id": TELEGRAM_CHAT_ID,
        "text": message,
        "parse_mode": "Markdown", # Use Markdown for formatting
        "disable_web_page_preview": False # Allow link previews
    }
    try:
        response = requests.post(url, json=payload, timeout=10)
        response.raise_for_status()
        print(f"Message sent to Telegram. Response: {response.json()}")
    except requests.exceptions.RequestException as e:
        print(f"Error sending message to Telegram: {e}")
```

## Step 6: The Main Bot Loop

This is where all the pieces come together to create a continuously running bot.

```python
def main_bot_loop():
    """
    The main loop of the bot. Continuously checks for new mints and sends notifications.
    """
    print("postfun Telegram Bot started...")
    while True:
        last_seen_id = get_last_seen_id()
        print(f"Checking for new mints (Last seen ID: {last_seen_id})...")

        new_mints = get_latest_mints()

        if new_mints:
            # Sort by ID to ensure we process in ascending order (oldest new mint first)
            # This is crucial for correctly updating last_seen_id
            new_mints.sort(key=lambda x: x.get('id', '')) # Assuming 'id' is comparable

            for tweet in new_mints:
                # Assuming 'id' is a string. If it's an integer, compare as int.
                # Here, we assume IDs are sequential or can be compared lexicographically.
                # For real tweet IDs, it's safer to use creation time or a numerical internal ID.
                if last_seen_id is None or tweet.get('id', '') > str(last_seen_id):
                    message = format_message(tweet)
                    send_telegram_message(message)
                    save_last_seen_id(tweet.get('id', '')) # Update last seen after successful send
        else:
            print("No new mints found or error occurred.")

        print(f"Next check in {POLLING_INTERVAL_SECONDS} seconds.")
        time.sleep(POLLING_INTERVAL_SECONDS)

if __name__ == "__main__":
    main_bot_loop()
```

## Running Your Bot

1.  **Save the code:** Save the entire script as `postfun_bot.py`.
2.  **Install dependencies:** `pip install requests`
3.  **Set environment variables:** Before running, set your `TELEGRAM_BOT_TOKEN` and `TELEGRAM_CHAT_ID` as environment variables:
    ```bash
    export TELEGRAM_BOT_TOKEN="YOUR_ACTUAL_BOT_TOKEN"
    export TELEGRAM_CHAT_ID="YOUR_ACTUAL_CHAT_ID"
    python postfun_bot.py
    ```
4.  **Run:** `python postfun_bot.py`

Your bot will now start polling the `postfun` API and sending notifications to your Telegram chat!

## Next Steps & Enhancements

This is a basic bot, but it can be significantly enhanced:

*   **Error Handling & Logging:** Add more robust logging (`logging` module) for debugging and monitoring, especially for API errors or network issues.
*   **Asynchronous Operations:** For more complex bots handling many users or real-time events, consider using `python-telegram-bot`'s built-in asynchronous features (e.g., `asyncio`).
*   **Interactive Commands:** Add Telegram commands like `/stats` to fetch current `postfun` platform statistics, or `/price [tweet_id]` to get the current price of a specific pool.
*   **Database for State:** For more persistent and reliable state management (especially if the bot is restarted frequently), use a small database (e.g., SQLite) instead of a text file for `last_seen_tweet_id`.
*   **Monitoring:** Set up basic monitoring to ensure your bot is always running.
*   **Deployment:** Deploy your bot to a cloud server (e.g., AWS EC2, DigitalOcean Droplet, Railway) to ensure it runs 24/7.
